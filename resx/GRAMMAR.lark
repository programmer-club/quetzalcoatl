%import common.CNAME
%import common.ESCAPED_STRING
%import common.FLOAT
%import common.NUMBER

COMMENT : /\/\/.+?\n/

%ignore COMMENT

%import common.WS

%ignore WS

word : CNAME
str : ESCAPED_STRING

// Definitions of base atoms
atom_variable : word
atom_expression : "$" word
atom_constant : "@" word
atom_set : "#" word

raw_expression : str | ("0" ("x" | "b") ?) ? NUMBER | FLOAT

// Compound Expressions
// TODO: allow expressions?
set_expression : (word ("<" (atom_set ",")* atom_set (",")? ">")? ("^" NUMBER)? ("->" set_expression)? ("|" set_expression)? ("x" set_expression)?) | "#" "(" set_expression ")"

set_declaration : set_body | metaset_body

set_body : "set" word inheritance? "{" asterix_set_body "}"

// *set_body = (meta)set body
asterix_set_body : properties ";" phrase*

properties : word "|" (has ",")* has?

has : is_made_in | has_property | has_operator

is_made_in : word "is" "made" "in" set_mapping_specifier // x is made in (#a x #b -> Tuple<#a, #b>)

has_property : word "has" "property" word "in" set_expression // x has property a in #a

has_operator : word "has" "operator" operator "in" set_mapping_specifier // x has operator + in (Tuple<#a, #b> ^ 2 -> Tuple<#a, #b>)

show_phrase : "show" operator "in" set_mapping_specifier "[" (word ",")* word? "]" "=" function_body
// show + in (Tuple<#a, #b>^2 -> Tuple<#a, #b>) [x, y] = make Tuple<#a, #b> [x.a + y.a, x.b + y.b]

make_phrase : "make" word set_mapping_specifier "[" (word ",")* word? "]" function_with_locals_body

inheritance : "<=" set_expression

metaset_body : "metaset" word "<" (atom_set ",")* atom_set? ">" "in" "(" (set_expression ",")* set_expression? ")" inheritance?

function_declaration : ((("declare" word) | "Î»") ":" set_mapping_specifier "[" (word ",")* word? "]" "->" function_body)

set_mapping_specifier : ("(" set_expression "->" set_expression ")")

function_body : expression | ("{" phrase* "}")

function_with_locals_body : expression | ("{" (phrase | (local_set ";"))* "}")

local_set : word "->" atom_expression "=" expression

typedef : "typedef" set_expression "is" set_expression

function_call : (word "(" (expression ",")* expression? ")")

let_statement : "let" (exp_set_statement | typed_let)

exp_set_statement : (atom_expression "=" expression)

typed_let : "typed" atom_expression "in" set_expression "=" expression

arithmetic : expression operator expression

operator : "+" | "-" | "*" | "/" | "^" | "<" | "<=" | ">" | ">=" | "==" | "!=" | ".." // TODO: instanceof

find_statement : ("find" atom_expression "=" expression ("where" (constant_set ",")* constant_set? )?)

constant_set : atom_variable "=" expression

if_block : if elif* else?

if : "if" "[" expression "]" function_body

elif : "elif" "[" expression "]" function_body

else : "else" function_body

make_expression : "make" set_expression "[" (expression ",")* expression? "]"

// Expression time!
expression : (atom_expression | atom_variable | atom_constant | make_expression | show_phrase | make_phrase | set_declaration | if_block | function_declaration | typedef | function_call | let_statement | exp_set_statement | find_statement | arithmetic | raw_expression | "(" expression ")")

// Compound Phrases

// Finally, phrase
phrase : (expression) ";"

// Start
start : phrase*