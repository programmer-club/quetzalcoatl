//declare F : (R^2 -> R) [a, b] -> ($a + $b);
//print (map (declare anonymous : (R -> R) [a] -> a ^ 2, 1 .. infinity));
//print (map (λ : (R -> R) [a] -> a ^ 2, 1 .. infinity));
// λ = declare anonymous

// a = 2; // SyntaxError, cannot set variable to value
let $a = 2; // Valid
let $b = (2 * x);

if [ $a == 2 ] {
    print ($a);
} else if [ $a == 42 ] {
    print ($a);
} else {
    print (2);
};

// no pointers, but arrow notation anyway :)
// let lets you declare typed variables
let $x = ((3 * (x ^ 2)) + (2 * x) - 3);
print(find $x = 0 for x);
// NoVariable

// also supports imaginary!
let $im = (x^2);
// negative numbers do not currently work :(
// hence 0 - 1
print(find $im = (0 - 1) for x);

print(d(x^2));

print(Integral(x^2, make_tuple(x, 0, 10)));

print (find (∫ ((x ^ 2) + x, x)) = 0 for x);

// y in R
// @a, @b, @c declares a, b, c as constants and not variables
let typed $y in R = @a * x ^2 + @b * x + @c;
find $y = 0 for x;
// UnsolvableException
find $y = 0 where a = 0, b = 1, c = 0 for x;
// Solution { x: [0] }

// no types, only sets
set S { // native implementation of Tuple
    x | x has property a in R,
        x has property b in R,
        x has operator + in (S x S | R -> S),
        x has operator - in (S x S | R -> S),
        x has operator * in (S x S | R -> S),
        x has operator / in (S x S | R -> S),
        x is made in (R^2 -> S)
        ;

    make S (R^2 -> S) [a, b] {
        x->$a = a;
        x->$b = b;

        x;
    };

    show + in (S^2 -> S) [x, y] = make S [x->$a + y->$a, x->$b + y->$b];
    show - in (S^2 -> S) [x, y] = make S [x->$a - y->$a, x->$b - y->$b];
    show * in (S^2 -> S) [x, y] = make S [x->$a * y->$a, x->$b * y->$b];
    show / in (S^2 -> S) [x, y] = make S [x->$a / y->$a, x->$b / y->$b];
    show + in (S x R -> S) [x, y] = make S [x->$a + y, x->$b + y];
    show - in (S x R -> S) [x, y] = make S [x->$a - y, x->$b - y];
    show * in (S x R -> S) [x, y] = make S [x->$a * y, x->$b * y];
    show / in (S x R -> S) [x, y] = make S [x->$a / y, x->$b / y];
};

set UnitCircle <= S { // UnitCircle
    x | x->$a ^ 2 + x->$b ^ 2 is 1;
};

// metaset is a set of sets (i.e. generic type)
// #set is a Set parametre (i.e. generic type variable)
// #(U) is the Hashset of U (universal set) (i.e. every possible set)
//                                           note that #(U) <= U, but x in #(U) | x is a Set = #(U),
//                                           but x in U | x is a Set =/= U
// <= #set is dynamic inheritance (i.e. Bounded<R, ...> <= R);
metaset BoundedB <#set, $lower, $upper> in (#(U), U, U) <= #set {
    x | $lower < x is 1,
        $upper >= x is 1;
};

metaset BoundedA <#set, $lower, $upper> in (#(U), U, U) <= #set {
    x | $lower <= x is 1,
        $upper > x is 1;
};

// aliases
typedef Radian is BoundedB<R, -π, π>;

// note: the Standard Library tuple is as follows:
metaset Tuple <#a, #b> in (#(U), #(U)) { // native implementation of Tuple
    x | x has property a in #a,
        x has property b in #b,
        x has operator + in (Tuple<#a, #b> ^ 2 -> Tuple<#a, #b>),
        x has operator - in (Tuple<#a, #b> ^ 2 -> Tuple<#a, #b>),
        x has operator * in (Tuple<#a, #b> ^ 2 -> Tuple<#a, #b>),
        x has operator / in (Tuple<#a, #b> ^ 2 -> Tuple<#a, #b>),
        x is made in (#a x #b -> Tuple<#a, #b>)
        ;

    make Tuple (#a x #b -> Tuple<#a, #b>) [a, b] {
        x->$a = $a;
        x->$b = $b;

        x;
    };

    show + in (Tuple<#a, #b>^2 -> Tuple<#a, #b>) [x, y] = make Tuple<#a, #b> [x->$a + y->$a, x->$b + y->$b];
    show - in (Tuple<#a, #b>^2 -> Tuple<#a, #b>) [x, y] = make Tuple<#a, #b> [x->$a - y->$a, x->$b - y->$b];
    show * in (Tuple<#a, #b>^2 -> Tuple<#a, #b>) [x, y] = make Tuple<#a, #b> [x->$a * y->$a, x->$b * y->$b];
    show / in (Tuple<#a, #b>^2 -> Tuple<#a, #b>) [x, y] = make Tuple<#a, #b> [x->$a / y->$a, x->$b / y->$b];
};